## Список вопросов:

----

1.  [Архитектура фон Неймана, принципы фон Неймана.](#архитектура-фон-неймана-принципы-фон-неймана)
2.  [Машинные команды, машинный код. Понятие языка ассемблера.](#машинные-команды-машинный-код-понятие-языка-ассемблера)
3.  [Виды памяти ЭВМ. Запуск и исполнение программы.](#виды-памяти-эвм-запуск-и-исполнение-программы)
4.  [Сегментная модель памяти в архитектуре 8086.](#сегментная-модель-памяти-в-архитектуре-8086)
5.  [Процессор 8086. Регистры общего назначения.](#процессор-8086-регистры-общего-назначения)
6.  [Процессор 8086. Сегментные регистры. Адресация в реальном режиме. Понятие сегментной части адреса и смещения.](#процессор-8086-сегментные-регистры-адресация-в-реальном-режиме-понятие-сегментной-части-адреса-и-смещения)
7.  [Процессор 8086. Регистр флагов.](#процессор-8086-регистр-флагов)
8.  [Команды пересылки данных.](#команды-пересылки-данных)
9.  [Команда сравнения.](#команда-сравнения)
10. [Команды условной и безусловной передачи управления.](#команды-условной-и-безусловной-передачи-управления)
11. [Арифметические команды.](#арифметические-команды)
12. [Двоично-десятичная арифметика.](#двоично-десятичная-арифметика)
13. [Команды побитовых операций. Логические команды.](#команды-побитовых-операций-логические-команды)
14. [Команды работы со строками.](#команды-работы-со-строками)
15. [Команда трансляции по таблице.](#команда-трансляции-по-таблице)
16. [Команда вычисления эффективного адреса.](#команда-вычисления-эффективного-адреса)
17. [Структура программы на языке ассемблера. Модули. Сегменты.](#структура-программы-на-языке-ассемблера-модули-сегменты)
18. [Виды ассемблеров. Intel-синтаксис, АТ&Т-синтаксис.](#виды-ассемблеров-intel-синтаксис-атт-синтаксис)
19. [Подпрограммы. Объявление, вызов.](#подпрограммы-объявление-вызов)
20. [Подпрограммы. Возврат управления.](#подпрограммы-возврат-управления)
21. [Макроопределения.](#макроопределения)
22. [Стек. Аппаратная поддержка вызова подпрограмм.](#стек-аппаратная-поддержка-вызова-подпрограмм)
23. [Соглашения о вызовах. Понятие, основные виды соглашений.](#соглашения-о-вызовах-понятие-основные-виды-соглашений)
24. [Прерывания. Обработка прерываний в реальном режиме работы процессора.](#прерывания-обработка-прерываний-в-реальном-режиме-работы-процессора)
25. [Процессор 80386. Режимы работы. Регистры.](#процессор-80386-режимы-работы-регистры)
26. [Страничная модель памяти. Виртуальная память.](#страничная-модель-памяти-виртуальная-память)
27. [Математический сопроцессор. Типы данных.](#математический-сопроцессор-типы-данных)
28. [Математический сопроцессор. Регистры.](#математический-сопроцессор-регистры)
29. [Математический сопроцессор. Классификация команд.](#математический-сопроцессор-классификация-команд)
30. [Расширения процессора. ММХ. Регистры, поддерживаемые типы данных.](#расширения-процессора-ммх-регистры-поддерживаемые-типы-данных)
31. [Расширения процессора. ММХ. Классификация команд.](#расширения-процессора-ммх-классификация-команд)
32. [Расширения процессора. SSE. Регистры, поддерживаемые типы данных.](#расширения-процессора-sse-регистры-поддерживаемые-типы-данных)
33. [Расширения процессора. SSE. Классификация команд.](#расширения-процессора-sse-классификация-команд)
34. [Расширения процессора. AVX. Регистры, поддерживаемые типы данных.](#расширения-процессора-avx-регистры-поддерживаемые-типы-данных)
35. [Расширения процессора. AVX. Классификация команд.](#расширения-процессора-avx-классификация-команд)
36. [Процессоры семейства х86-64. Регистры, режимы работы.](#процессоры-семейства-х86-64-регистры-режимы-работы)
37. [Расширения процессора. AES. Назначение, классификация команд.](#расширения-процессора-aes-назначение-классификация-команд)
38. [Архитектура RISC. Семейство процессоров ARM. Версии архитектуры, профили.](#архитектура-risc-семейство-процессоров-arm-версии-архитектуры-профили)
39. [Процессоры ARM. Наборы команд. Основные регистры.](#процессоры-arm-наборы-команд-основные-регистры)
40. [Процессоры ARM. Основные команды.](#процессоры-arm-основные-команды)
---
## Ответы

---

---
## 1. Архитектура фон Неймана. Принципы фон Неймана

### Архитектура фон Неймана
![устройство-процессора.jpg](pic/устройство-процессора.jpg)
>* Процессор состоит из блоков УУ и АЛУ
>* УУ - дискретный конечный автомат.
Структурно состоит из: дешифратора команд (операций), регистра команд, узла вычислений текущего исполнительного адреса, счётчика команд (регистр IP).
>* АЛУ - под управлением УУ производит преобразование над данными (операндами). Разрядность операнда - длина машинного слова. (Машинное слово - машинно-зависимая величина, измеряемая в битах, равная разрядности регистров/шины данных)

### Принципы фон Неймана (архитектуры фон Неймана):  
> 1. Использование двоичной системы счисления в вычислительных машинах (0 - нет сигнала, 1 - есть сигнал).
> 2. Программное управление ЭВМ.  
> 3. Память компьютера используется не только для хранения данных, но и программ.*
> 4. Ячейки памяти ЭВМ имеют адреса, которые последовательно пронумерованы (от нуля до максимального значения). Каждый адрес ячейки по сути является переменной, с которой можно работать отдельно.
> 5. Возможность условного перехода в процессе выполнения программы (необходима для реализации сложных алгоритмов, т.к. без неё нельзя было бы строить нелинейные алгоритмы с ветвлениями и т.д.).
>
>> *Практическое значение: данные и код в оперативной памяти ничем не отличаются, что позволяет функционировать компиляторам и использовать единую память и для кода, и для данных, что сильно упрощает построение программ в целом. Но это приводит к ошибкам, когда мы случайно или специально перезаписываем что-то поверх кода и программа ломается. Решение проблемы: флаг WP в регистре CR0 (лекция 5).
---

---
## 2. Машинные команды, машинный код. Понятие языка ассемблера.

---
***Машинная команда*** - инструкция (в двоичном коде) из аппаратно определённого набора, которую способен выполнять процессор.

***Машинный код*** - система команд конкретной вычислительной машины, которая интерпретируется непосредственно процессором.

***Язык ассемблера*** - машинно-зависимый язык программирования низкого уровня, команды которого прямо соответствуют машинным командам.

---

---
## 3. Виды памяти ЭВМ. Запуск и исполнение программы.

---
### Схема ЭВМ
![схема-эвм.png](pic/схема-эвм.png)

### Виды памяти
**Байт** - минимальная адресуемая единица памяти (8 бит).  

**Машинное слово** - машинно-зависимая величина, измеряемая в битах, равная разрядности регистров/шины данных.

**Параграф** - 16 байт

Память делится на внешнюю и внутреннюю  
К внутренней памяти относится:
* **ОЗУ** (оперативное запоминающее устройство)
  * **DRAM (Dynamic RAM)**: Основной тип оперативной памяти, которая периодически обновляется.
  * **SRAM (Static RAM)**: Быстрая и дорогая память, обычно используется в кэшах.
* **ПЗУ** (постоянное запоминающее устройство). 
  *  **ROM (Read-Only Memory)**: Память, из которой можно только читать, используется для хранения микропрограмм и прошивок.
  * **EPROM (Erasable Programmable ROM)**: Память, которая может быть стерта и перепрограммирована с помощью ультрафиолетового света.
  * **EEPROM (Electrically Erasable Programmable ROM)**: Память, которая может быть стерта и перепрограммирована электрически.

> В ПЗУ хранится информация, которая записывается туда при изготовлении ЭВМ. Важнейшая микросхема ПЗУ - BIOS.

### Выполнение программы
> 1. Определение формата файла (.COM или .EXE, в случае 8086)
> 2. Чтение и разбор заголовка
> 3. Считывание разделов исполняемого модуля (файла) в ОЗУ по необходимым адресам.
> 4. Подготовка к запуску, если требуется. (установка регистров; настройка окружения, загрузка библиотек (см. 1 ЛР, 2 часть))
> 5. Передача управления на точку входа. 
> 6. Дальше выполняются инструкции заданные в самой программе.

---

---

## 4. Cегментная модель памяти в архитектуре 8086.

---

Сегментная модель памяти в архитектуре 8086

1. Сегменты памяти:
   - Память делится на сегменты размером до 64 КБ.
   - Каждый сегмент начинается с адреса, кратного 16 байтам (параграфу).
   - Основные сегменты: сегмент кода, сегмент данных, сегмент стека и дополнительные сегменты.

2. Регистры сегментов:
   - CS (Code Segment): Указывает на сегмент, содержащий исполняемый код.
   - DS (Data Segment): Указывает на сегмент, содержащий данные.
   - SS (Stack Segment): Указывает на сегмент, используемый для стека.
   - ES (Extra Segment): Используется для дополнительных данных и операций с памятью.

3. Смещение (Offset):
   - Адресация в сегменте осуществляется с помощью смещения (offset), представляющего собой 16-битное значение.
   - Смещение указывает на положение внутри сегмента и может принимать значения от 0 до 65535 (0xFFFF).

4. Формирование физических адресов:
   - Физический адрес вычисляется как комбинация содержимого регистра сегмента и смещения.
   - Формула для вычисления физического адреса:
     Физический адрес = (Содержимое регистра сегмента << 4) + Смещение

```
Пример формирования физического адреса:
Допустим, CS = 0x1234 и IP (Instruction Pointer) = 0x5678.  
Вычисление физического адреса:  
   Физический адрес = (0x1234 << 4) + 0x5678  
                    = 0x12340 + 0x5678  
                    = 0x179B8
```
---

---

## [Процессор 8086](#процессор-8086-архитектура) архитектура

---
### Устройство 8086
![устройство-8086.png](pic/устройство-8086.png)

### Архитектура 8086 с точки зрения программиста (структура блока регистров).
![arch-8086.png](pic/arch-8086.png)
---

---


## [Процессор 8086](#процессор-8086-архитектура). Регистры общего назначения.

---

Регистры общего назначения: **AX, BX, CX, DX**.  
Каждый из регистров имеет старшую и младшую часть, по 1 байту на каждый.

---

---

## [Процессор 8086](#процессор-8086-архитектура). Сегментные регистры. [Адресация в реальном режиме. Понятие сегментной части адреса и смещения](#cегментная-модель-памяти-в-архитектуре-8086).

---

Архитектура 8086 имеет четыре сегментных регистра:
* CS (code segment)
* SS (stack segment) 
* DS (data segment) 
* ES (extra segment)
> Каждый сегментный регистр определяет адрес начала сегмента в памяти, при этом сегменты могут совпадать или пересекаться. По умолчанию регистр CS используется при выборке инструкций, регистр SS при выполнении операций со стеком, регистры DS и ES при обращении к данным

**Логический адрес** записывают как сегмент:смещение (и те, и те в 16 с/с). В реальном режиме для вычисления физического адреса, адрес из сегмента сдвигают влево на 4 разряда (можно сказать, что просто приписывают 0 в конце или умножают на 16) и добавляют смещение.  
`Например, логический адрес 7522:F139 дает физический адрес 84359.`  

На шину передается именно физический адрес. Если результат больше, чем 2^20 - 1, то 21 бит отбрасывают.
Такой режим работы процессора называют реальным режимом адресации процессора  
`При такой адресации адреса 0400h:0001h и 0000h:4001h будут ссылаться на одну и ту же ячейку памяти, так как 400h × 16 + 1 = 0 × 16 + 4001h.`

---

---

## [Процессор 8086](#процессор-8086-архитектура). Регистр флагов.


---
Флаги **выставляются при операциях**, но не обязательно все сразу. Например INC и DEC не затрагивают флаг CF, в отличии от ADD и SUB.

Также есть команды рассчитанные на флаги, например CMP, которая выставляет флаги такие, как если бы произошло вычитание аргументов.

**Как мы помним, регистры у нас размером в 16 бит.**

| 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10  | 11  | 12   | 13   | 14 | 15 |
|----|----|----|----|----|----|----|----|----|----|-----|-----|------|------|----|----|
| CF | -  | PF | -  | AF | -  | ZF | SF | TF | IF | DF  | OF  | IOPL | IOPL | NT | -  |


■ CF (carry flag) - флаг переноса - устанавливается в 1, если результат предыдущей операции не уместился в приемник и произошел перенос или если требуется заем при вычитании. Иначе 0.

■ PF (parity flag) - флаг чётности - устанавливается в 1, если младший байт результата предыдущей операции содержит четное количество единиц.

■ AF (auxiliary carry flag) - вспомогательный флаг переноса - устанавливается в 1, если в результате предыдущей операции произошел перенос из 3 в 4 или заем из 4 в 3 биты.

■ ZF (zero flag) - флаг нуля - устанавливается в 1, если результат предыдущей команды равен 0.

■ SF (sign flag) - флаг знака - всегда равен старшему биту результата.

■ TF (trap flag) - флаг трассировки - предусмотрен для работы отладчиков в пошаговом режиме. Если поставить в 1, после каждой команды будет происходить передача управления отладчику.

■ IF (interrupt enable flag) - флаг разрешения прерываний - если 0 процессор перестает обрабатывать прерывания от внешних устройств.

■ DF (direction flag) - флаг направления - контролирует поведение команд обработки строк. Если 0, строки обрабатываются слева направо, если 1 справа налево.

■ OF (overflowflag) - флаг переполнения - устанавливается в 1, если результат предыдущей операции над числами со знаком выходит за допустимые для них пределы.

■ IOPL (I/O privilege level) - уровень приоритета ввода-вывода - а это на 286, на не нужно пока.

■ NT (nested task) - флаг вложенности задач - а это на 286, на не нужно пока.

---

---

## Команды пересылки данных.

---


### MOV <приемник>, <источник>.  
* Приемник: POH (регистр общего назначения), сегментный регистр, переменная (то есть ячейка памяти)  
* Источник: непосредственный операнд (например, число), POH, сегментный регистр, переменная

**Нельзя загрузить в сегментный регистр значение непосредственно из памяти**. Поэтому для этого используют промежуточный регистр (в начале лабы всегда так делали).

**Переменные не могут быть одновременно и источником, и приемником.**

``` 
Пример:

Правильно:
MOV AX, 5
MOV BX, DX
MOV [1234h], CH
MOV DS, AX

Неправильно:
MOV [0123h], [2345h] ; нельзя напрямую скопировать переменную в переменную, 
; т.к. процессор может либо что-то считать из памяти (в регистры), либо записать в неё (из регистров)
MOV DS, 1000h        ; в сегментные регистры нельзя напрямую записывать константы,
; т.е. в сегментные регистры можно записывать значения только из регистров общего назначения

```

### XCHG <операнд1>, <операнд2>

Обмен операндов между собой. Выполнятеся либо над двумя регистрами, либо регистр + переменная.


---

---

## Команда сравнения.

---
### CMP <приемник>, <источник>
**Источник** - число, регистр или переменная.  
**Приемник** - регистр или переменная; не может быть переменной одновременно с источником.

Вычитает источник из приёмника, результат никуда не сохраняется, выставляются флаги **CF, PF, AF, ZF, SF, OF**.

### TEST <приемник>, <источник>
Аналог **AND**, но результат не сохраняется. Выставляются флаги **SF, ZF, PF**.

Можно использовать для проверки на ноль, например ```TEST bx, bx```

---

---

## Команды условной и безусловной передачи управления.

---

**Условный переход** - переход, происходящий при выполнении какого-то условия.

**Безусловный переход** - переход, не зависящий от чего-либо (совершаемый в любом случае).

### Виды безусловных переходов

**JMP** - оператор безусловного перехода.   

| Вид перехода      | Дистанция перехода                           |
|-------------------|----------------------------------------------|
| short (короткий)  | -128..+127 байт                              |
| near (ближний)    | в том же сегменте (без изменения CS)         |
| far (дальний)     | в другой сегмент (со сменой CS)              |


Для короткого и ближнего переходов непосредственный операнд (число) прибавляется к **IP**. Регистры и переменные заменяют старое значение в **IP (CS:IP)**.

### Команда безусловной передачи управления JMP

JMP <операнд>

- Передаёт управление в другую точку программы, не сохраняя какой-либо информации для возврата.
- Операнд - непосредственный адрес, регистр или переменная.

### Команды условных переходов J.. (Зубков, Assembler, …, глава 2)
- Переход типа short или near
- Обычно используются в паре с CMP
- "Выше" и "ниже" - при сравнении беззнаковых чисел
- "Больше" и "меньше" - при сравнении чисел со знаком

|Команда|Описание|Состояние флагов для выполнения перехода|
|---|---|---|
|JO   |Есть переполнение   |OF = 1   |
|JNO   |Нет переполнения   |OF = 0   |
|JS   |Есть знак   |SF = 1   |
|JNS   |Нет знака    |SF = 0   |
|JE/JZ   |Если равно/если ноль   |ZF = 1   |
|JNE/JNZ   |Не равно/не ноль   |ZF = 0   |
|JP/JPE   |Есть чётность/чётное   |PF = 1   |
|JNP/JPO   |Нет чётности/нечётное   |PF = 0   |
|JCXZ   |CX = 0   |   |

|Команда|Описание|Состояние флагов для выполнения перехода|Знаковый|
|---|---|---|---|
|JB | Если ниже|CF = 1   |Нет |
|JNAE   |Если не выше и не равно  |CF = 1   |Нет |
|JC   |Если перенос  |CF = 1   |Нет |
|JNB   |Если не ниже   |CF = 0   |Нет   |
|JAE   |Если выше или равно   |CF = 0   |Нет   |
|JNC   |Если нет переноса   |CF = 0   |Нет   |
|JBE   |Есть ниже или равно   |CF = 1 или ZF = 1   |Нет   |
|JNA   |Если не выше   |CF = 1 или ZF = 1   |Нет   |
|JA   |Если выше   |CF = 0 и ZF = 0   |Нет   |
|JNBE   |Если не ниже и не равно   |CF = 0 и ZF = 0   |Нет   |
|JL   |Если меньше   |SF <> OF   |Да   |
|JNGE   |Если не больше и не равно   |SF <> OF   |Да   |
|JGE   |Если больше или равно   |SF = OF   |Да   |
|JNL   |Если не меньше   |SF = OF   |Да   |
|JLE   |Если меньше или равно   |ZF = 1 или SF <> OF    |Да   |
|JNG   |Если не больше   |ZF = 1 или SF <> OF    |Да   |
|JG   |Если больше   |ZF = 0 и SF = OF   |Да   |
|JNLE   |Если не меньше и не равно   |ZF = 0 и SF = OF   |Да   |


```assembly
Пример

    ...
    XOR AX, AX
    MOV BX, 5
label1:
    INC AX
    ADD BX, AX
    JMP label 1
```

---

---

## Арифметические команды.

---
### Целочисленная арифметика (основные команды).
- `ADD <приёмник>, <источник>` - выполняет арифметическое сложение приёмника и источника. Сумма помещается в приёмник, источник не изменяется.
- `SUB <приёмник>, <источник>` - арифметическое вычитание источника из приёмника.
- `MUL <источник>` - беззнаковое умножение. Умножаются источник и `AL/AX`, в зависимости от размера (разрядности) источника (если 1 байт, то `AL`, а если 2 байта, то на `AX`). Результат помещается в `AX` (если 1 байт умножался на 1 байт; то есть предполагается, что результат может быть в 2 раза длиннее аргумента) либо `DX:AX` (если 2 байта умножались на 2 байта; предполагается, что результат получится 4-байтовым, и его старшие 2 байта помещаются в `DX`, младшие 2 - в `AX`).
- `DIV <источник>` - целочисленное беззнаковое деление. Делится `AL/AX` на источник. Результат помещается в `AL/AX`, остаток - в `AH/DX`. Выбор регистра опять зависит от разрядности источника (закономерность аналогична умножению).
- `INC <приёмник>` - инкремент на 1.
- `DEC <приёмник>` - декремент на 1.

### Побитовая арифметика (основные команды).
- `AND <приёмник>, <источник>` - побитовое “И”. 
  ```asm
  AND al, 00001111b
  ```
- `OR <приёмник>, <источник>` - побитовое “ИЛИ”. 
  ```asm
  OR al, 00001111b
  ```
- `XOR <приёмник>, <источник>` - побитовое исключающее “ИЛИ”. 
  ```asm
  XOR AX, BX
  XOR AX, AX - быстрое зануление
  ```
- `NOT <приёмник>` - инверсия
  ```asm
  NOT AX
  ```

---

---

## Двоично-десятичная арифметика.

---

---

## Команды побитовых операций. Логические команды.

---

---

## Команды работы со строками.

---

---

## Команда трансляции по таблице.

---

---

## Команда вычисления эффективного адреса.

---

---

## Структура программы на языке ассемблера. Модули. Сегменты.

---

---

## Виды ассемблеров. Intel-синтаксис, АТ&Т-синтаксис.

---

---

## Подпрограммы. Объявление, вызов.

---

---

## Подпрограммы. Возврат управления.

---

---

## Макроопределения.

---

---

## Стек. Аппаратная поддержка вызова подпрограмм.

---

---

## Соглашения о вызовах. Понятие, основные виды соглашений.

---

---

## Прерывания. Обработка прерываний в реальном режиме работы процессора.

---

---

## Процессор 80386. Режимы работы. Регистры.

---

---

## Страничная модель памяти. Виртуальная память.

---

---

## Математический сопроцессор. Типы данных.

---

---

## Математический сопроцессор. Регистры.

---

---

## Математический сопроцессор. Классификация команд.

---

---

## Расширения процессора. ММХ. Регистры, поддерживаемые типы данных.

---

---

## Расширения процессора. ММХ. Классификация команд.

---

---

## Расширения процессора. SSE. Регистры, поддерживаемые типы данных.

---

---

## Расширения процессора. SSE. Классификация команд.

---

---

## Расширения процессора. AVX. Регистры, поддерживаемые типы данных.

---

---

## Расширения процессора. AVX. Классификация команд.

---

---

## Процессоры семейства х86-64. Регистры, режимы работы.

---

---

## Расширения процессора. AES. Назначение, классификация команд.

---

---

## Архитектура RISC. Семейство процессоров ARM. Версии архитектуры, профили.

---

---

## Процессоры ARM. Наборы команд. Основные регистры.

---

---

## Процессоры ARM. Основные команды.

---

---


